<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XAUUSD NUCLEAR SMC vC ‚Äî Enhanced (TP tiers, monitoring, filters)</title>
  <style>
    :root { --bg:#0b0c0f; --card:#111216; --accent:#06f; --good:#064; --bad:#600; --muted:#9aa; color-scheme: dark; }
    body{ background:var(--bg); color:#fff; font-family:Inter, system-ui, Arial; padding:20px; margin:0; }
    .wrap{ max-width:980px; margin:0 auto; }
    h1{ margin:0 0 8px 0; font-size:20px; }
    p.small{ color:var(--muted); margin:6px 0 16px 0; }
    label{ font-size:13px; color:var(--muted); display:block; margin-top:8px; }
    input, select{ width:100%; padding:10px; border-radius:8px; border:1px solid #222; background:var(--card); color:#fff; margin-top:6px; }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:8px; align-items:start; }
    .full{ grid-column: 1 / -1; }
    button{ padding:10px 14px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer; margin:8px 6px 8px 0; }
    button.stop{ background:#c33; }
    .status{ padding:10px; background:#0d0f12; border-radius:8px; margin-top:12px; }
    .signalBox{ padding:12px; margin-top:12px; border-radius:8px; display:none; }
    .logs{ background:#000; color:#0f0; padding:10px; height:320px; overflow:auto; border-radius:6px; margin-top:12px; font-family:monospace; white-space:pre-line; }
    .infoRow{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .chip{ background:#0d0f12; padding:6px 10px; border-radius:8px; color:var(--muted); font-size:13px; }
    small{ color:var(--muted); }
    .hint{ font-size:12px; color:var(--muted); margin-top:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>XAUUSD NUCLEAR SMC vC ‚Äî Enhanced</h1>
    <p class="small">Refined SMC + Liquidity Grab detection. 8 indicators ‚Üí signal when 5+ confirm. Added: EMA filter, 1H RSI filter, TP tiers, partials, trailing SL to BE, position-size estimate, monitoring & Telegram alerts.</p>

    <label>TwelveData API Key (fill after hosting)</label>
    <input id="td_key" placeholder="ENTER HERE AFTER UPLOAD (do NOT commit to repo)">

    <label>Telegram Bot Token</label>
    <input id="tg_token" placeholder="123456:ABC...">

    <label>Chat IDs (comma separated) ‚Äî include channel id if posting to channel (e.g. -100123...)</label>
    <input id="tg_chats" placeholder="12345678,-1001234567890">

    <div class="row full">
      <div>
        <label>Account Balance (USD) ‚Äî for position estimate</label>
        <input id="acct_balance" placeholder="1000">
      </div>
      <div>
        <label>Risk per trade (%)</label>
        <input id="risk_pct" placeholder="0.5">
      </div>

      <div>
        <label>TP sizes (comma %) ‚Äî TP1,TP2,TP3 (example: 30,30,40)</label>
        <input id="tp_sizes" placeholder="30,30,40">
      </div>
      <div>
        <label>EMA trend filter (1h) ‚Äî min confirmations (ENABLED/disabled)</label>
        <select id="ema_filter">
          <option value="on">On ‚Äî require 1H EMA50 direction</option>
          <option value="off">Off</option>
        </select>
      </div>

      <div>
        <label>RSI filter (1h) ‚Äî max allowed RSI for LONG (prevents buying into overbought)</label>
        <input id="rsi_long_max" placeholder="65">
      </div>
      <div>
        <label>RSI filter (1h) ‚Äî min allowed RSI for SHORT (prevents shorting into oversold)</label>
        <input id="rsi_short_min" placeholder="35">
      </div>
    </div>

    <div class="infoRow">
      <button id="startBtn">Start Bot</button>
      <button id="stopBtn" class="stop">Stop Bot</button>
      <div class="chip" id="runStatus">Status: Stopped</div>
      <div class="chip" id="lastSignal">Last Signal: ‚Äî</div>
    </div>

    <div id="signal" class="signalBox"></div>

    <div class="status" id="summary">Config: XAU/USD ‚Ä¢ 15m/1h/4h analysis ‚Ä¢ 1-min scheduler (browser)</div>

    <div class="logs" id="logs"></div>
  </div>

<script>
/*
  ENHANCED XAUUSD NUCLEAR SMC vC
  - Original 8 indicators remain
  - Added: EMA(50) trend filter on 1H, RSI(14) filter on 1H
  - TP tiers: partial exits + breakeven move
  - Active monitoring loop notifies Telegram on TP hits / SL hits
*/

// ============== CONFIG ==============
const SYMBOL = "XAU/USD";
const INTERVAL_MS = 60 * 1000;            // scan every 60s (browser)
const COOLDOWN_MS = 60 * 60 * 1000;       // 1 hour between signals
const MIN_CONFIRM = 5;                    // signal threshold
const LOOKBACK_M15 = 200;
const LOOKBACK_1H  = 200;
const LOOKBACK_4H  = 120;
const VOLUME_MULT = 2.2;
const WICK_ATR_MULT = 1.1;
const ATR_INCREASE_MULT = 1.15;
const MSS_LOOKBACK = 30;
const RR = 4;
const MONITOR_INTERVAL_MS = 15 * 1000;    // monitor every 15s
// =====================================

let loopId = null;
let running = false;
let lastSignalTime = 0;

const logsEl = document.getElementById('logs');
const statusEl = document.getElementById('runStatus');
const lastSignalEl = document.getElementById('lastSignal');
const signalBox = document.getElementById('signal');

function log(msg){
  const t = new Date().toLocaleString();
  logsEl.innerText += `[${t}] ${msg}\n`;
  logsEl.scrollTop = logsEl.scrollHeight;
}
function setStatus(txt){ statusEl.innerText = 'Status: ' + txt; }
function setLastSignal(txt){ lastSignalEl.innerText = 'Last Signal: ' + txt; }

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function safeNum(v){ return typeof v === 'number' && !isNaN(v) ? v : 0; }
function fmt(n, d=2){ return Number(n).toFixed(d); }

// ============== Twelve Data fetch ==============
async function fetchTD(intervalKey, limit){
  const key = document.getElementById('td_key').value.trim();
  if(!key){ log('TwelveData key missing'); return []; }
  const map = {'15m':'15min','1h':'1h','4h':'4h','1m':'1min'};
  const intv = map[intervalKey] || intervalKey;
  const url = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(SYMBOL)}&interval=${intv}&apikey=${encodeURIComponent(key)}&outputsize=${limit}&format=JSON&timezone=UTC`;
  try{
    const r = await fetch(url);
    const j = await r.json();
    if(!j || !j.values){ log('TD error: ' + (j && j.message ? j.message : JSON.stringify(j))); return []; }
    return j.values.reverse().map(v=>({
      t: new Date(v.datetime).getTime(),
      o: safeNum(parseFloat(v.open)),
      h: safeNum(parseFloat(v.high)),
      l: safeNum(parseFloat(v.low)),
      c: safeNum(parseFloat(v.close)),
      v: safeNum(parseFloat(v.volume || 0))
    }));
  }catch(e){
    log('FetchTD err: '+ e.message);
    return [];
  }
}

// ============== Technical helpers ==============
function ATR(candles, period=14){
  if(!candles || candles.length < period+1) return 0;
  const trs = [];
  for(let i=1;i<candles.length;i++){
    const cur=candles[i], prev=candles[i-1];
    trs.push(Math.max(cur.h - cur.l, Math.abs(cur.h - prev.c), Math.abs(cur.l - prev.c)));
  }
  let atr = trs.slice(0,period).reduce((a,b)=>a+b,0) / period;
  for(let i=period;i<trs.length;i++){
    atr = (atr*(period-1) + trs[i]) / period;
  }
  return atr;
}

function SMA_of_ATR_series(candles, atrPeriod=14, smaPeriod=20){
  if(candles.length < atrPeriod + smaPeriod) return 0;
  const atrs = [];
  for(let start=0; start <= candles.length - atrPeriod - 1; start++){
    const slice = candles.slice(start, start + atrPeriod + 1);
    atrs.push(ATR(slice, atrPeriod));
  }
  const lastSMAPeriod = atrs.slice(-smaPeriod);
  return lastSMAPeriod.reduce((a,b)=>a+b,0)/lastSMAPeriod.length;
}

function EMA(values, period){
  if(!values || values.length < period) return null;
  const k = 2/(period+1);
  let ema = values.slice(0,period).reduce((a,b)=>a+b,0)/period; // SMA first
  for(let i=period;i<values.length;i++){
    ema = values[i] * k + ema * (1 - k);
  }
  return ema;
}

function RSI(candles, period=14){
  if(!candles || candles.length < period+1) return null;
  let gains=0, losses=0;
  for(let i=candles.length-period;i<candles.length;i++){
    const change = candles[i].c - candles[i-1].c;
    if(change>0) gains += change;
    else losses += Math.abs(change);
  }
  const avgGain = gains/period;
  const avgLoss = losses/period;
  if(avgLoss === 0) return 100;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}

function detectOB(candles){
  let bull = null, bear = null;
  for(let i=3;i<candles.length-2;i++){
    const p = candles[i-1], x = candles[i];
    if(p.c < p.o && x.c > x.o && x.c > p.h && x.l <= p.l) bull = { price: p.l, idx: i-1 };
    if(p.c > p.o && x.c < x.o && x.c < p.l && x.h >= p.h) bear = { price: p.h, idx: i-1 };
  }
  return { bull, bear };
}

function detectFVG(candles){
  for(let i=2;i<candles.length;i++){
    const a=candles[i-2], x=candles[i];
    if(a.h < x.l) return 'bull';
    if(a.l > x.h) return 'bear';
  }
  return null;
}

function isVolumeSpike(candles, mult=VOLUME_MULT){
  if(!candles || candles.length < 12) return false;
  const last = candles[candles.length-1].v;
  const avg = candles.slice(-11,-1).reduce((s,c)=>s+(c.v),0) / 10;
  return last > avg * mult;
}

function trendBiasFrom4h(h4){
  if(!h4 || h4.length < 20) return 'neutral';
  const closes = h4.map(c=>c.c);
  const sma20 = closes.slice(-21,-1).reduce((a,b)=>a+b,0) / 20;
  const last = closes[closes.length-1];
  return last > sma20 ? 'bull' : last < sma20 ? 'bear' : 'neutral';
}

function detectMSS(candles){
  if(!candles || candles.length < MSS_LOOKBACK + 5) return null;
  const start = Math.max(0, candles.length - MSS_LOOKBACK);
  let swingHigh = -Infinity, swingLow = Infinity;
  for(let i=start;i<candles.length;i++){
    if(candles[i].h > swingHigh) swingHigh = candles[i].h;
    if(candles[i].l < swingLow) swingLow = candles[i].l;
  }
  const last = candles[candles.length-1];
  if(last.h > swingHigh && last.c < last.o) return 'mss_bull_break';
  if(last.l < swingLow && last.c > last.o) return 'mss_bear_break';
  return null;
}

function detectLiquidityGrab(candles){
  if(!candles || candles.length < 20) return { top:false, bottom:false, atr:0, vol:false };
  const atr = ATR(candles, 14);
  let swingHigh = -Infinity, swingLow = Infinity;
  const look = 20;
  for(let i=Math.max(0, candles.length - look); i < candles.length; i++){
    if(candles[i].h > swingHigh) swingHigh = candles[i].h;
    if(candles[i].l < swingLow) swingLow = candles[i].l;
  }
  const last = candles[candles.length-1];
  const wickTop = last.h - Math.max(last.c, last.o);
  const wickBottom = Math.min(last.c, last.o) - last.l;
  const volOk = isVolumeSpike(candles, VOLUME_MULT);
  const topSweep = (last.h > swingHigh) && (wickTop > atr * WICK_ATR_MULT) && (last.c < last.o) && volOk;
  const bottomSweep = (last.l < swingLow) && (wickBottom > atr * WICK_ATR_MULT) && (last.c > last.o) && volOk;
  return { top: topSweep, bottom: bottomSweep, atr, volOk };
}

function atrVolatilityShift(candles){
  const atrNow = ATR(candles,14);
  const atrSMA = SMA_of_ATR_series(candles,14,20);
  if(!atrSMA) return false;
  return atrNow > atrSMA * ATR_INCREASE_MULT;
}

// ============== Position sizing & TP builder ==============
function getTPSizes(){
  const s = document.getElementById('tp_sizes') ? document.getElementById('tp_sizes').value.trim() : '';
  if(!s) return [30,30,40];
  const arr = s.split(',').map(x=>parseFloat(x)).filter(x=>!isNaN(x));
  if(arr.length !== 3) return [30,30,40];
  // normalize if not 100
  const sum = arr.reduce((a,b)=>a+b,0);
  if(sum !== 100){
    return arr.map(x => Math.round(x / sum * 100));
  }
  return arr;
}

// crude estimate: units = riskUSD / stopPips
function estimatePositionSize(entry, sl){
  const bal = parseFloat(document.getElementById('acct_balance')?.value) || 1000;
  const riskPct = parseFloat(document.getElementById('risk_pct')?.value) || 0.5;
  const riskUSD = bal * (riskPct/100);
  const stopPips = Math.abs(entry - sl);
  if(stopPips <= 0) return {units:0, riskUSD};
  const units = Math.floor(riskUSD / stopPips);
  return {units, riskUSD};
}

function buildTPs(entry, sl, direction){
  const risk = (direction==='LONG') ? (entry - sl) : (sl - entry);
  const tp1 = (direction==='LONG') ? entry + risk * 1.0 : entry - risk * 1.0;
  const tp2 = (direction==='LONG') ? entry + risk * 2.0 : entry - risk * 2.0;
  const tp3 = (direction==='LONG') ? entry + risk * RR : entry - risk * RR;
  const tps = [tp1, tp2, tp3];
  const tpSizesPct = getTPSizes(); // e.g. [30,30,40]
  const sizes = tpSizesPct.map(p=>p/100);
  return { tps, sizes };
}

// ============== Active signals & monitoring ==========
const activeSignals = [];
let monitorId = null;
function uid(){ return 's' + Date.now() + Math.floor(Math.random()*1000); }

async function sendToTelegram(msgHtml){
  const token = document.getElementById('tg_token').value.trim();
  if(!token){ log('TG token not set'); return false; }
  const chatStr = document.getElementById('tg_chats').value.trim();
  if(!chatStr){ log('No chat IDs'); return false; }
  const chatIds = chatStr.split(',').map(s=>s.trim()).filter(s=>s.length);
  let allOk = true;
  for(const id of chatIds){
    const url = `https://api.telegram.org/bot${encodeURIComponent(token)}/sendMessage?chat_id=${encodeURIComponent(id)}&text=${encodeURIComponent(msgHtml)}&parse_mode=HTML&disable_web_page_preview=true`;
    try{
      const res = await fetch(url);
      const j = await res.json();
      if(j && j.ok) log('Sent to ' + id);
      else { log('TG err: ' + JSON.stringify(j)); allOk = false; }
    }catch(e){
      log('TG send failed: ' + e.message);
      allOk = false;
    }
    await sleep(250);
  }
  return allOk;
}

async function monitorActiveSignals(){
  if(!activeSignals.length){
    if(monitorId){ clearInterval(monitorId); monitorId = null; }
    return;
  }
  const latest = await fetchTD('1m', 2);
  if(!latest || !latest.length) return;
  const price = latest[latest.length-1].c;

  for(const sig of activeSignals){
    if(sig.status !== 'open') continue;
    const dir = sig.direction;
    // check TPs
    for(let i=0;i<sig.tps.length;i++){
      if(sig.filledSizes[i] >= 1) continue;
      const tp = sig.tps[i];
      let hit = false;
      if(dir==='LONG' && price >= tp) hit = true;
      if(dir==='SHORT' && price <= tp) hit = true;
      if(hit){
        sig.filledSizes[i] = 1;
        // after TP1 move SL to breakeven+small buffer
        if(i===0){
          const buffer = Math.max( (ATR(latest,14) || 0.5) * 0.2, 0.1);
          if(dir==='LONG') sig.sl = Math.max(sig.sl, sig.entry + buffer);
          else sig.sl = Math.min(sig.sl, sig.entry - buffer);
        }
        const portionPct = Math.round(sig.sizes[i]*100);
        const msg = `<b>‚úÖ TP${i+1} HIT</b>\n${dir==='LONG'?'üü¢ LONG':'üî¥ SHORT'}\nTP${i+1}: <b>${fmt(tp,2)}</b>\nPortion: <b>${portionPct}%</b>\nNew SL: <b>${fmt(sig.sl,2)}</b>\nTime: ${new Date().toLocaleString()}`;
        await sendToTelegram(msg);
        log(`Signal ${sig.id} TP${i+1} hit at ${fmt(price)} (tp ${fmt(tp)})`);
      }
    }

    // check SL
    let slHit = false;
    if(dir==='LONG' && price <= sig.sl) slHit = true;
    if(dir==='SHORT' && price >= sig.sl) slHit = true;
    if(slHit){
      const filled = sig.filledSizes.reduce((a,b)=>a+b,0);
      const remaining = 1 - filled;
      const posEst = estimatePositionSize(sig.entry, sig.sl);
      let realizedUsd = 0;
      for(let i=0;i<sig.tps.length;i++){
        if(sig.filledSizes[i]) {
          const exit = sig.tps[i];
          const pnlPerUnit = (dir==='LONG') ? (exit - sig.entry) : (sig.entry - exit);
          realizedUsd += pnlPerUnit * posEst.units * sig.sizes[i];
        }
      }
      const pnlOnRemainingPerUnit = (dir==='LONG') ? (sig.sl - sig.entry) : (sig.entry - sig.sl);
      const pnlRemaining = pnlOnRemainingPerUnit * posEst.units * remaining;
      const totalPnl = realizedUsd + pnlRemaining;
      const msg = `<b>‚õî SL HIT ‚Äî TRADE CLOSED</b>\n${dir==='LONG'?'üü¢ LONG':'üî¥ SHORT'}\nSL: <b>${fmt(sig.sl,2)}</b>\nPrice: <b>${fmt(price,2)}</b>\nEstimated P&L: <b>$${fmt(totalPnl,2)}</b>\nTime: ${new Date().toLocaleString()}`;
      await sendToTelegram(msg);
      log(`Signal ${sig.id} SL hit at ${fmt(price)}; est P&L $${fmt(totalPnl,2)}`);
      sig.status = 'closed';
    }

    // all TPs filled?
    const allFilled = sig.filledSizes.every(x=>x>=1);
    if(allFilled && sig.status === 'open'){
      const posEst = estimatePositionSize(sig.entry, sig.sl);
      let totalPnl = 0;
      for(let i=0;i<sig.tps.length;i++){
        const exit = sig.tps[i];
        const pnlPerUnit = (dir==='LONG') ? (exit - sig.entry) : (sig.entry - exit);
        totalPnl += pnlPerUnit * posEst.units * sig.sizes[i];
      }
      const msg = `<b>üèÅ ALL TPs HIT ‚Äî TRADE CLOSED</b>\n${dir==='LONG'?'üü¢ LONG':'üî¥ SHORT'}\nFinal Price: <b>${fmt(price,2)}</b>\nEstimated P&L: <b>$${fmt(totalPnl,2)}</b>\nTime: ${new Date().toLocaleString()}`;
      await sendToTelegram(msg);
      log(`Signal ${sig.id} all TPs hit; est P&L $${fmt(totalPnl,2)}`);
      sig.status = 'closed';
    }
  }

  // cleanup old closed
  const cutoff = Date.now() - 6*60*60*1000;
  for(let i = activeSignals.length -1; i>=0; i--){
    if(activeSignals[i].status === 'closed' || activeSignals[i].createdAt < cutoff){
      activeSignals.splice(i,1);
    }
  }
  if(!activeSignals.length && monitorId){ clearInterval(monitorId); monitorId = null; }
}

// ============== SCAN (main) ==============
async function scanOnce(){
  try{
    const [m15, h1, h4] = await Promise.all([
      fetchTD('15m', LOOKBACK_M15),
      fetchTD('1h', LOOKBACK_1H),
      fetchTD('4h', LOOKBACK_4H)
    ]);

    if(!m15.length || m15.length < 40){
      log('Not enough M15 data');
      return;
    }
    if(!h1.length || h1.length < 40){
      log('Not enough 1H data');
      return;
    }

    const price = m15[m15.length-1].c;
    const atr15 = ATR(m15, 14);
    const ob15 = detectOB(m15.slice(-80));
    const ob1h = detectOB(h1.slice(-80));
    const fvg = detectFVG(m15.slice(-30));
    const volSpike = isVolumeSpike(m15);
    const bias4h = trendBiasFrom4h(h4);
    const atrShift = atrVolatilityShift(m15);
    const mss = detectMSS(m15);
    const liq = detectLiquidityGrab(m15);

    // New filters: EMA50 on 1H & RSI14 on 1H
    const closes1h = h1.map(c=>c.c);
    const ema50_1h = EMA(closes1h, 50);
    const rsi1h = RSI(h1, 14);

    const ind1 = !!(ob15.bull || ob15.bear);
    const ind2 = !!(ob1h.bull || ob1h.bear);
    const ind3 = !!fvg;
    const ind4 = volSpike;
    const ind5 = bias4h !== 'neutral';
    const ind6 = atrShift;
    const ind7 = !!mss;
    const ind8 = (liq.top || liq.bottom) && liq.volOk;

    const indicators = [ind1, ind2, ind3, ind4, ind5, ind6, ind7, ind8];
    let confirmed = indicators.filter(x=>x).length;

    // Apply EMA trend filter if enabled
    const emaFilterOn = (document.getElementById('ema_filter')?.value || 'on') === 'on';
    let trendOK = true;
    if(emaFilterOn && ema50_1h){
      // For LONG we require price > EMA50 on 1H; for SHORT require price < EMA50 on 1H
      // We'll check the current 1H close vs ema50
      const last1h = h1[h1.length-1].c;
      // if majority of indicators suggest LONG (basic), else SHORT
      const biasSuggestsLong = (ind1 || ind3 || ind4 || ind5 || ind7 || ind8);
      if(biasSuggestsLong && last1h < ema50_1h) trendOK = false;
      if(!biasSuggestsLong && last1h > ema50_1h) trendOK = false;
    }

    // RSI filter
    const rsiLongMax = parseFloat(document.getElementById('rsi_long_max')?.value) || 65;
    const rsiShortMin = parseFloat(document.getElementById('rsi_short_min')?.value) || 35;
    let rsiOK = true;
    if(rsi1h){
      // If signals mostly LONG and RSI > rsiLongMax ‚Äî block
      const biasSuggestsLong = (ind1 || ind3 || ind4 || ind5 || ind7 || ind8);
      if(biasSuggestsLong && rsi1h > rsiLongMax) rsiOK = false;
      const biasSuggestsShort = (ind2 || ind3 || ind4 || ind5 || ind7 || ind8);
      if(biasSuggestsShort && rsi1h < rsiShortMin) rsiOK = false;
    }

    log(`Price ${fmt(price)} | Confirmed ${confirmed}/8 | 1H RSI:${rsi1h?fmt(rsi1h,2):'n/a'} EMA50:${ema50_1h?fmt(ema50_1h,2):'n/a'}`);

    if(Date.now() - lastSignalTime < COOLDOWN_MS){
      if(confirmed >= MIN_CONFIRM) log('Signal blocked by cooldown');
      return;
    }

    if(confirmed >= MIN_CONFIRM && trendOK && rsiOK){
      // Decide direction: liquidity dominant -> decide, else mss/bias4h
      let direction = 'LONG';
      if(liq.top) direction = 'SHORT';
      else if(liq.bottom) direction = 'LONG';
      else if(mss && mss.includes('bear')) direction = 'SHORT';
      else if(mss && mss.includes('bull')) direction = 'LONG';
      else direction = (bias4h === 'bull') ? 'LONG' : (bias4h === 'bear') ? 'SHORT' : 'LONG';

      // final sanity: check EMA if on
      if(emaFilterOn && ema50_1h){
        const last1h = h1[h1.length-1].c;
        if(direction === 'LONG' && last1h < ema50_1h){
          log('Blocked by EMA trend (LONG requires 1H>EMA50)');
          return;
        }
        if(direction === 'SHORT' && last1h > ema50_1h){
          log('Blocked by EMA trend (SHORT requires 1H<EMA50)');
          return;
        }
      }

      const entry = price;
      const slBuffer = Math.max(atr15 * 1.2, 0.5);
      let sl = (direction === 'LONG') ? entry - slBuffer : entry + slBuffer;
      const { tps, sizes } = buildTPs(entry, sl, direction);

      const pos = estimatePositionSize(entry, sl);

      const entryF = fmt(entry,2), slF = fmt(sl,2), tpF = tps.map(x=>fmt(x,2)).join(', ');

      const msgLines = [];
      msgLines.push('<b>‚ö° XAUUSD NUCLEAR SMC vC ‚Äî SIGNAL</b>');
      msgLines.push(direction === 'LONG' ? 'üü¢ <b>LONG</b>' : 'üî¥ <b>SHORT</b>');
      msgLines.push('');
      msgLines.push(`Entry: <b>${entryF}</b>`);
      msgLines.push(`SL: <b>${slF}</b>`);
      msgLines.push(`TPs: <b>${tpF}</b>`);
      msgLines.push(`TP distribution: <b>${getTPSizes().join('% , ')}%</b>`);
      msgLines.push(`Est. units: <b>${pos.units}</b> (risk $${fmt(pos.riskUSD,2)})`);
      msgLines.push(`RR: <b>1:${RR}</b>`);
      msgLines.push('');
      msgLines.push(`<b>Confirmed:</b> ${confirmed}/8`);
      if(rsi1h) msgLines.push(`<b>1H RSI:</b> ${fmt(rsi1h,2)}`);
      if(ema50_1h) msgLines.push(`<b>1H EMA50:</b> ${fmt(ema50_1h,2)}`);
      msgLines.push(`Time: ${new Date().toLocaleString()}`);

      const tgMsg = msgLines.join('\n');

      const ok = await sendToTelegram(tgMsg);

      if(ok){
        const sig = {
          id: uid(),
          direction,
          entry,
          sl,
          tps,
          sizes,
          filledSizes: [0,0,0],
          status: 'open',
          createdAt: Date.now()
        };
        activeSignals.push(sig);
        log('Registered active signal id=' + sig.id + ' direction=' + direction);
        if(!monitorId) monitorId = setInterval(monitorActiveSignals, MONITOR_INTERVAL_MS);
      } else {
        log('Signal NOT registered because TG failed');
      }

      lastSignalTime = Date.now();
      setLastSignal(new Date().toLocaleTimeString());
      signalBox.style.display = 'block';
      signalBox.style.background = (direction==='LONG') ? '#063' : '#600';
      signalBox.innerHTML = tgMsg.replace(/\n/g,'<br>');
      log('SIGNAL SENT -> ' + direction);
    } else {
      if(confirmed >= MIN_CONFIRM) {
        if(!trendOK) log('Signal blocked by EMA trend filter');
        if(!rsiOK) log('Signal blocked by RSI filter');
      }
    }

  }catch(e){
    log('Scan error: ' + (e && e.message ? e.message : e));
  }
}

// ============== Control ==============
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(running) return;
  const key = document.getElementById('td_key').value.trim();
  if(!key){
    alert('TwelveData API key daalo pehle.');
    return;
  }
  running = true;
  setStatus('Running');
  log('Bot started');
  scanOnce();
  loopId = setInterval(scanOnce, INTERVAL_MS);
});

document.getElementById('stopBtn').addEventListener('click', ()=>{
  if(loopId) clearInterval(loopId);
  if(monitorId) clearInterval(monitorId);
  running = false;
  monitorId = null;
  setStatus('Stopped');
  log('Bot stopped');
});

if(location.hostname.includes('github.io')){
  setTimeout(()=>{
    const k=document.getElementById('td_key').value.trim();
    const t=document.getElementById('tg_token').value.trim();
    if(k && t){ document.getElementById('startBtn').click(); }
  }, 3000);
}

</script>
</body>
</html>